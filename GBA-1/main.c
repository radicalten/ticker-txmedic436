// metroidlite_gba_singlefile.c
//
// A tiny “Metroid-like” side-scroller for GBA using tonc for GFX/input and
// maxmod for audio (music + SFX). Everything gameplay/graphics is in this file.
//
// IMPORTANT (maxmod assets):
//   Maxmod normally wants a soundbank produced by mmutil. To keep this “single file”,
//   you paste the generated soundbank bytes + IDs into the section below.
//   Without that, this will not link/run with sound enabled.
//
// Build expectations:
//   - devkitARM + libgba
//   - tonc (tonclib) installed and on include/lib path
//   - maxmod installed (devkitPro)
//
// References:
//   - Tonc (J. Vijn) programming tutorial / reference: https://www.coranac.com/tonc/text/  [1]
//   - devkitPro Maxmod overview: https://devkitpro.org/wiki/Maxmod  [2]

#include <tonc.h>
#include <maxmod.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>

#define RGB15_C(r,g,b)  ((r) | ((g) << 5) | ((b) << 10))

// ------------------------------------------------------------
// Maxmod single-file embedding hook
// ------------------------------------------------------------
//
// 1) Put a couple WAVs and a MOD/XM (or just WAVs) in a folder, e.g.:
//      jump.wav, shoot.wav, hit.wav, music.mod
//
// 2) Run mmutil to create soundbank.bin + soundbank.h (names vary by flags).
//    Example (adjust to your toolchain; mmutil CLI differs a bit across setups):
//      mmutil -d soundbank.bin -h soundbank.h jump.wav shoot.wav hit.wav music.mod
//
// 3) Convert soundbank.bin into a C array, then paste it below.
//    One simple method:
//      xxd -i soundbank.bin > soundbank_bin.inc
//    Then paste the generated `unsigned char soundbank_bin[] = {...};` here.
//
// 4) Also paste/replicate the IDs from soundbank.h (SFX_*, MOD_*).
//
// If you don’t want sound yet, set USE_MAXMOD to 0.

#define USE_MAXMOD 1

#if USE_MAXMOD

// ---- PASTE SECTION BEGIN -----------------------------------
// Paste your `soundbank_bin` array and ID defines here.

// Example placeholders (WILL NOT WORK UNTIL REPLACED):
__attribute__((aligned(4)))
static const unsigned char soundbank_bin[] = {
    // Replace with real mmutil-generated bytes.
    0x00
};

// Replace these IDs with the ones from your generated soundbank.h:
enum
{
    MOD_MUSIC = 0
};

enum
{
    SFX_JUMP  = 0,
    SFX_SHOOT = 1,
    SFX_HIT   = 2
};

// ---- PASTE SECTION END -------------------------------------

static void vblank_isr(void)
{
    // Maxmod wants this in VBlank when using IRQ mixing.
    mmVBlank();
}

#endif

// ------------------------------------------------------------
// Fixed point helpers (8.8)
// ------------------------------------------------------------
#define FX_SHIFT 8
#define FX(n) ((n) << FX_SHIFT)
#define INT(x) ((x) >> FX_SHIFT)

// ------------------------------------------------------------
// World / tilemap setup (Mode 0 BG0, 4bpp tiles)
// ------------------------------------------------------------
#define ROOM_W_TILES 64
#define ROOM_H_TILES 32
#define ROOM_W_PX (ROOM_W_TILES * 8)
#define ROOM_H_PX (ROOM_H_TILES * 8)

#define T_EMPTY 0
#define T_SOLID 1
#define T_DOOR  2

static u16 g_map[ROOM_W_TILES * ROOM_H_TILES];
static int g_room = 0;

// BG tiles: 3 tiles, 4bpp. Each tile is 8x8, 32 bytes = 8 u32.
__attribute__((aligned(4)))
static const u32 bg_tiles_4bpp[3 * 8] =
{
    // Tile 0: empty (all 0)
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,

    // Tile 1: solid block (border=2, fill=1)
    0x22222222,
    0x21111112,
    0x21111112,
    0x21111112,
    0x21111112,
    0x21111112,
    0x21111112,
    0x22222222,

    // Tile 2: door (frame=4, center=3)
    0x44444444,
    0x43333334,
    0x43344334,
    0x43344334,
    0x43344334,
    0x43344334,
    0x43333334,
    0x44444444,
};

static const u16 bg_pal[16] =
{
    RGB15_C(0,0,0),       // 0
    RGB15_C(10,10,10),    // 1 fill
    RGB15_C(24,24,24),    // 2 border
    RGB15_C(0,10,20),     // 3 door center
    RGB15_C(0,20,31),     // 4 door border
    RGB15_C(31,31,31),    // 5
    0,0,0,0,0,0,0,0,0,0
};

// ------------------------------------------------------------
// Sprites (OBJ) (simple 4bpp tiles)
// ------------------------------------------------------------
#define OBJ_TILE_PLAYER 0     // start index in OBJ tile memory
#define OBJ_TILE_BULLET 16    // arbitrary gap
#define OBJ_TILE_ENEMY  32

// 16x16 sprite = 4 tiles = 32 u32
__attribute__((aligned(4)))
static const u32 spr_player_4bpp[32] =
{
    // Top-left tile (8x8)
    0x00011000,
    0x00122100,
    0x01222210,
    0x01233210,
    0x01222210,
    0x00122100,
    0x00011000,
    0x00000000,

    // Top-right tile
    0x00001100,
    0x00012210,
    0x00122221,
    0x00123321,
    0x00122221,
    0x00012210,
    0x00001100,
    0x00000000,

    // Bottom-left tile
    0x00000000,
    0x00011000,
    0x00122100,
    0x01222210,
    0x01222210,
    0x00122100,
    0x00011000,
    0x00000000,

    // Bottom-right tile
    0x00000000,
    0x00001100,
    0x00012210,
    0x00122221,
    0x00122221,
    0x00012210,
    0x00001100,
    0x00000000
};

// 8x8 bullet = 1 tile = 8 u32
__attribute__((aligned(4)))
static const u32 spr_bullet_4bpp[8] =
{
    0x00000000,
    0x00055000,
    0x00555500,
    0x05555550,
    0x05555550,
    0x00555500,
    0x00055000,
    0x00000000
};

// 16x16 enemy = 4 tiles = 32 u32
__attribute__((aligned(4)))
static const u32 spr_enemy_4bpp[32] =
{
    0x00066000,
    0x00677600,
    0x06777760,
    0x06788760,
    0x06777760,
    0x00677600,
    0x00066000,
    0x00000000,

    0x00006600,
    0x00067760,
    0x00677776,
    0x00678876,
    0x00677776,
    0x00067760,
    0x00006600,
    0x00000000,

    0x00000000,
    0x00066000,
    0x00677600,
    0x06777760,
    0x06777760,
    0x00677600,
    0x00066000,
    0x00000000,

    0x00000000,
    0x00006600,
    0x00067760,
    0x00677776,
    0x00677776,
    0x00067760,
    0x00006600,
    0x00000000
};

static const u16 obj_pal[16] =
{
    RGB15_C(0,0,0),       // 0 transparent
    RGB15_C(31,31,31),    // 1 player fill
    RGB15_C(31,0,0),      // 2 player outline
    RGB15_C(31,16,0),     // 3 accent
    RGB15_C(0,0,0),       // 4 unused
    RGB15_C(31,31,0),     // 5 bullet
    RGB15_C(0,31,0),      // 6 enemy fill
    RGB15_C(0,0,31),      // 7 enemy outline
    RGB15_C(31,0,31),     // 8 enemy eye
    0,0,0,0,0,0,0
};

// ------------------------------------------------------------
// Entities
// ------------------------------------------------------------
typedef struct Bullet
{
    bool active;
    s32 x, y;     // 8.8 fixed
    s32 vx;       // 8.8 fixed
} Bullet;

typedef struct Enemy
{
    bool active;
    int hp;
    s32 x, y;     // 8.8 fixed
    s32 vx;
    int dir;      // -1 or +1
} Enemy;

typedef struct Player
{
    s32 x, y;     // 8.8 fixed (top-left)
    s32 vx, vy;
    bool on_ground;
    int facing;   // -1 left, +1 right
    int hp;
    int invuln;
} Player;

#define MAX_BULLETS 8
#define MAX_ENEMIES 6

static Bullet g_bullets[MAX_BULLETS];
static Enemy  g_enemies[MAX_ENEMIES];
static Player g_pl;

// Camera (pixels, integer)
static int cam_x = 0;
static int cam_y = 0;

// OAM buffer
static OBJ_ATTR obj_buffer[128];

// ------------------------------------------------------------
// Map helpers
// ------------------------------------------------------------
static inline u16 map_get_tile(int tx, int ty)
{
    if(tx < 0 || tx >= ROOM_W_TILES || ty < 0 || ty >= ROOM_H_TILES)
        return T_SOLID; // treat outside as solid
    return g_map[ty * ROOM_W_TILES + tx] & 0x03FF;
}

static inline bool tile_is_solid(u16 t)
{
    return (t == T_SOLID);
}

static inline bool solid_at_pixel(int px, int py)
{
    int tx = px >> 3;
    int ty = py >> 3;
    return tile_is_solid(map_get_tile(tx, ty));
}

static inline bool door_at_pixel(int px, int py)
{
    int tx = px >> 3;
    int ty = py >> 3;
    return map_get_tile(tx, ty) == T_DOOR;
}

static void build_room(int id, u16 *dst)
{
    // Basic layout: walls + floor + a couple platforms + doors at edges.
    for(int y=0; y<ROOM_H_TILES; y++)
    {
        for(int x=0; x<ROOM_W_TILES; x++)
        {
            u16 t = T_EMPTY;

            // Border walls/floor/ceiling:
            if(x == 0 || x == ROOM_W_TILES-1 || y == 0 || y == ROOM_H_TILES-1)
                t = T_SOLID;

            // Floor thickness:
            if(y >= ROOM_H_TILES-3)
                t = T_SOLID;

            // Platforms / obstacles differ per room:
            if(id == 0)
            {
                if(y == 18 && x >= 10 && x <= 22) t = T_SOLID;
                if(y == 14 && x >= 30 && x <= 45) t = T_SOLID;
                if(x == 26 && y >= 10 && y <= 17) t = T_SOLID; // pillar
            }
            else
            {
                if(y == 20 && x >= 8  && x <= 18) t = T_SOLID;
                if(y == 16 && x >= 22 && x <= 36) t = T_SOLID;
                if(y == 12 && x >= 40 && x <= 54) t = T_SOLID;
                if(x == 38 && y >= 10 && y <= 23) t = T_SOLID; // pillar
            }

            // Doors (2-tile high) near the bottom on left and right borders.
            // Doors are not solid; they just trigger transitions.
            if((x == 0 || x == ROOM_W_TILES-1) && (y == ROOM_H_TILES-5 || y == ROOM_H_TILES-4))
                t = T_DOOR;

            dst[y*ROOM_W_TILES + x] = t;
        }
    }
}

static void load_room_to_vram(void)
{
    // Put our room map into BG0 screenblock 30.
    // Using 64x32 map (512x256 px): BG size = 1 in REG_BGxCNT.
    memcpy16(se_mem[30], g_map, ROOM_W_TILES * ROOM_H_TILES);

    // Reset scroll
    cam_x = cam_y = 0;
    REG_BG0HOFS = 0;
    REG_BG0VOFS = 0;
}

// ------------------------------------------------------------
// Gameplay / physics
// ------------------------------------------------------------
static void reset_entities_for_room(int id)
{
    // Player spawn near left door
    g_pl.x = FX(16);
    g_pl.y = FX(ROOM_H_PX - 40);
    g_pl.vx = g_pl.vy = 0;
    g_pl.on_ground = false;
    g_pl.facing = +1;
    g_pl.hp = 99;
    g_pl.invuln = 0;

    for(int i=0; i<MAX_BULLETS; i++)
        g_bullets[i].active = false;

    for(int i=0; i<MAX_ENEMIES; i++)
    {
        g_enemies[i].active = true;
        g_enemies[i].hp = 3;
        g_enemies[i].dir = (i & 1) ? -1 : +1;
        g_enemies[i].vx = FX(1) / 2; // 0.5 px/frame
        g_enemies[i].x = FX(120 + i*48);
        g_enemies[i].y = FX(ROOM_H_PX - 40 - (id? (i%2)*24 : 0));
    }
}

static void change_room(int new_room, bool from_left)
{
    g_room = new_room;
    build_room(g_room, g_map);
    load_room_to_vram();

    // Place player just inside the opposite door
    if(from_left)
        g_pl.x = FX(16);
    else
        g_pl.x = FX(ROOM_W_PX - 32);

    g_pl.y = FX(ROOM_H_PX - 40);
    g_pl.vx = g_pl.vy = 0;
}

static void try_room_transition(void)
{
    // Use player center for door detection
    int px = INT(g_pl.x) + 8;
    int py = INT(g_pl.y) + 12;

    if(!door_at_pixel(px, py))
        return;

    // If at left edge door, go to other room entering from right; and vice versa.
    if(px < 8)
        change_room(g_room ^ 1, false);
    else if(px > ROOM_W_PX - 8)
        change_room(g_room ^ 1, true);
}

static void player_collide_and_move(void)
{
    // Player hitbox in pixels relative to top-left
    const int W = 14;
    const int H = 16;
    const int inset_x = 1; // to be slightly forgiving
    const int inset_y = 1;

    // --- Move X ---
    g_pl.x += g_pl.vx;

    int x = INT(g_pl.x);
    int y = INT(g_pl.y);

    if(g_pl.vx > 0)
    {
        int right = x + W - 1;
        int top   = y + inset_y;
        int bot   = y + H - 1 - inset_y;

        if(solid_at_pixel(right, top) || solid_at_pixel(right, bot))
        {
            int tx = (right >> 3);
            int snap = (tx << 3) - W; // align right side to tile boundary
            g_pl.x = FX(snap);
            g_pl.vx = 0;
        }
    }
    else if(g_pl.vx < 0)
    {
        int left = x;
        int top  = y + inset_y;
        int bot  = y + H - 1 - inset_y;

        if(solid_at_pixel(left, top) || solid_at_pixel(left, bot))
        {
            int tx = (left >> 3);
            int snap = ((tx + 1) << 3); // align left side to next tile boundary
            g_pl.x = FX(snap);
            g_pl.vx = 0;
        }
    }

    // --- Move Y ---
    g_pl.on_ground = false;
    g_pl.y += g_pl.vy;

    x = INT(g_pl.x);
    y = INT(g_pl.y);

    if(g_pl.vy > 0)
    {
        int left  = x + inset_x;
        int right = x + W - 1 - inset_x;
        int bot   = y + H - 1;

        if(solid_at_pixel(left, bot) || solid_at_pixel(right, bot))
        {
            int ty = (bot >> 3);
            int snap = (ty << 3) - H + 1;
            g_pl.y = FX(snap);
            g_pl.vy = 0;
            g_pl.on_ground = true;
        }
    }
    else if(g_pl.vy < 0)
    {
        int left  = x + inset_x;
        int right = x + W - 1 - inset_x;
        int top   = y;

        if(solid_at_pixel(left, top) || solid_at_pixel(right, top))
        {
            int ty = (top >> 3);
            int snap = ((ty + 1) << 3);
            g_pl.y = FX(snap);
            g_pl.vy = 0;
        }
    }

    // Prevent falling out of world (safety clamp)
    if(INT(g_pl.y) > ROOM_H_PX - 32)
    {
        g_pl.y = FX(ROOM_H_PX - 32);
        g_pl.vy = 0;
        g_pl.on_ground = true;
    }
}

static void spawn_bullet(void)
{
    for(int i=0; i<MAX_BULLETS; i++)
    {
        if(!g_bullets[i].active)
        {
            g_bullets[i].active = true;

            int px = INT(g_pl.x);
            int py = INT(g_pl.y);

            g_bullets[i].x = FX(px + 8);
            g_bullets[i].y = FX(py + 8);
            g_bullets[i].vx = (g_pl.facing > 0) ? FX(4) : -FX(4);

#if USE_MAXMOD
            mmEffect(SFX_SHOOT);
#endif
            return;
        }
    }
}

static void update_bullets(void)
{
    for(int i=0; i<MAX_BULLETS; i++)
    {
        if(!g_bullets[i].active)
            continue;

        g_bullets[i].x += g_bullets[i].vx;

        int bx = INT(g_bullets[i].x);
        int by = INT(g_bullets[i].y);

        // Offscreen/world bounds
        if(bx < 0 || bx >= ROOM_W_PX || by < 0 || by >= ROOM_H_PX)
        {
            g_bullets[i].active = false;
            continue;
        }

        // Hit wall
        if(solid_at_pixel(bx, by))
        {
            g_bullets[i].active = false;
            continue;
        }

        // Hit enemies
        for(int e=0; e<MAX_ENEMIES; e++)
        {
            if(!g_enemies[e].active)
                continue;

            int ex = INT(g_enemies[e].x);
            int ey = INT(g_enemies[e].y);

            // enemy bbox approx 16x16
            if(bx >= ex && bx < ex+16 && by >= ey && by < ey+16)
            {
                g_enemies[e].hp--;
                g_bullets[i].active = false;

#if USE_MAXMOD
                mmEffect(SFX_HIT);
#endif

                if(g_enemies[e].hp <= 0)
                    g_enemies[e].active = false;

                break;
            }
        }
    }
}

static void update_enemies(void)
{
    for(int i=0; i<MAX_ENEMIES; i++)
    {
        if(!g_enemies[i].active)
            continue;

        // simple walker: move, turn around at walls/edges
        s32 vx = (g_enemies[i].dir > 0) ? g_enemies[i].vx : -g_enemies[i].vx;
        g_enemies[i].x += vx;

        int ex = INT(g_enemies[i].x);
        int ey = INT(g_enemies[i].y);

        // Keep them roughly on the ground: apply gravity and collide with floor
        s32 vy = FX(1); // crude "gravity" for enemies
        g_enemies[i].y += vy;

        // Snap to ground
        if(solid_at_pixel(ex+2, ey+16) || solid_at_pixel(ex+13, ey+16))
        {
            int bot = ey + 16;
            int ty = (bot >> 3);
            int snap = (ty << 3) - 16 + 1;
            g_enemies[i].y = FX(snap);
        }

        // Wall check ahead at mid-height
        int ahead_x = (g_enemies[i].dir > 0) ? (ex + 16) : (ex - 1);
        if(solid_at_pixel(ahead_x, ey+8) || solid_at_pixel(ahead_x, ey+14))
        {
            g_enemies[i].dir = -g_enemies[i].dir;
        }

        // Also turn around at room borders
        if(ex < 8) g_enemies[i].dir = +1;
        if(ex > ROOM_W_PX-24) g_enemies[i].dir = -1;
    }
}

static void handle_player_enemy_contact(void)
{
    if(g_pl.invuln > 0)
    {
        g_pl.invuln--;
        return;
    }

    int px = INT(g_pl.x);
    int py = INT(g_pl.y);

    // approx 14x16
    for(int i=0; i<MAX_ENEMIES; i++)
    {
        if(!g_enemies[i].active)
            continue;

        int ex = INT(g_enemies[i].x);
        int ey = INT(g_enemies[i].y);

        bool overlap =
            (px < ex+16) && (px+14 > ex) &&
            (py < ey+16) && (py+16 > ey);

        if(overlap)
        {
            g_pl.hp -= 1;
            g_pl.invuln = 45; // ~0.75s at 60fps
            // small knockback
            g_pl.vx = (px < ex) ? -FX(2) : FX(2);
            g_pl.vy = -FX(2);
            return;
        }
    }
}

static void update_player(void)
{
    // Movement constants (8.8 fixed)
    const s32 ACCEL   = 40;      // ~0.156 px/frame^2
    const s32 FRICTION= 24;
    const s32 MAXVX   = FX(2);   // 2 px/frame
    const s32 GRAV    = 52;      // ~0.203 px/frame^2
    const s32 MAXVY   = FX(4);
    const s32 JUMPVY  = -FX(4);

    key_poll();

    u16 held = key_curr_state();
    u16 hit  = key_hit_state();

    // Horizontal acceleration
    if(held & KEY_LEFT)
    {
        g_pl.vx -= ACCEL;
        g_pl.facing = -1;
    }
    else if(held & KEY_RIGHT)
    {
        g_pl.vx += ACCEL;
        g_pl.facing = +1;
    }
    else
    {
        // friction
        if(g_pl.vx > 0) { g_pl.vx -= FRICTION; if(g_pl.vx < 0) g_pl.vx = 0; }
        if(g_pl.vx < 0) { g_pl.vx += FRICTION; if(g_pl.vx > 0) g_pl.vx = 0; }
    }

    // Clamp vx
    if(g_pl.vx >  MAXVX) g_pl.vx =  MAXVX;
    if(g_pl.vx < -MAXVX) g_pl.vx = -MAXVX;

    // Jump
    if((hit & KEY_A) && g_pl.on_ground)
    {
        g_pl.vy = JUMPVY;
        g_pl.on_ground = false;
#if USE_MAXMOD
        mmEffect(SFX_JUMP);
#endif
    }

    // Shoot
    if(hit & KEY_B)
        spawn_bullet();

    // Gravity
    g_pl.vy += GRAV;
    if(g_pl.vy > MAXVY) g_pl.vy = MAXVY;

    player_collide_and_move();
    try_room_transition();
    handle_player_enemy_contact();
}

static void update_camera(void)
{
    int px = INT(g_pl.x);
    int py = INT(g_pl.y);

    cam_x = px - (240/2 - 8);
    cam_y = py - (160/2 - 16);

    if(cam_x < 0) cam_x = 0;
    if(cam_y < 0) cam_y = 0;
    if(cam_x > ROOM_W_PX - 240) cam_x = ROOM_W_PX - 240;
    if(cam_y > ROOM_H_PX - 160) cam_y = ROOM_H_PX - 160;

    REG_BG0HOFS = (u16)cam_x;
    REG_BG0VOFS = (u16)cam_y;
}

// ------------------------------------------------------------
// Rendering
// ------------------------------------------------------------
static void hide_obj(OBJ_ATTR *obj)
{
    obj->attr0 = ATTR0_HIDE;
}

static void render(void)
{
    // Reserve OAM:
    //  0: player
    //  1..MAX_BULLETS: bullets
    //  1+MAX_BULLETS .. enemies
    int o = 0;

    // Player sprite
    {
        int sx = INT(g_pl.x) - cam_x;
        int sy = INT(g_pl.y) - cam_y;

        obj_set_attr(&obj_buffer[o],
            ATTR0_SQUARE,
            ATTR1_SIZE_16,
            ATTR2_PALBANK(0) | OBJ_TILE_PLAYER);

        obj_set_pos(&obj_buffer[o], sx, sy);

        // Flip based on facing
        if(g_pl.facing < 0) obj_buffer[o].attr1 |= ATTR1_HFLIP;
        else                obj_buffer[o].attr1 &= ~ATTR1_HFLIP;

        // Blink when invulnerable
        if(g_pl.invuln > 0 && (g_pl.invuln & 4))
            hide_obj(&obj_buffer[o]);

        o++;
    }

    // Bullets
    for(int i=0; i<MAX_BULLETS; i++)
    {
        if(!g_bullets[i].active)
        {
            hide_obj(&obj_buffer[o++]);
            continue;
        }

        int sx = INT(g_bullets[i].x) - cam_x;
        int sy = INT(g_bullets[i].y) - cam_y;

        obj_set_attr(&obj_buffer[o],
            ATTR0_SQUARE,
            ATTR1_SIZE_8,
            ATTR2_PALBANK(0) | OBJ_TILE_BULLET);
        obj_set_pos(&obj_buffer[o], sx, sy);
        o++;
    }

    // Enemies
    for(int i=0; i<MAX_ENEMIES; i++)
    {
        if(!g_enemies[i].active)
        {
            hide_obj(&obj_buffer[o++]);
            continue;
        }

        int sx = INT(g_enemies[i].x) - cam_x;
        int sy = INT(g_enemies[i].y) - cam_y;

        obj_set_attr(&obj_buffer[o],
            ATTR0_SQUARE,
            ATTR1_SIZE_16,
            ATTR2_PALBANK(0) | OBJ_TILE_ENEMY);

        obj_set_pos(&obj_buffer[o], sx, sy);

        if(g_enemies[i].dir < 0) obj_buffer[o].attr1 |= ATTR1_HFLIP;
        else                     obj_buffer[o].attr1 &= ~ATTR1_HFLIP;

        o++;
    }

    // Hide any remaining OAM entries
    for(; o<128; o++)
        hide_obj(&obj_buffer[o]);

    // Copy OAM in VBlank (we do it inside the VBlank wait region in main loop too),
    // but it’s fine to copy here if you call during VBlank.
}

// ------------------------------------------------------------
// Init
// ------------------------------------------------------------
static void init_gfx(void)
{
    // Mode 0, BG0 on, OBJ on, 1D OBJ tile mapping
    REG_DISPCNT = DCNT_MODE0 | DCNT_BG0 | DCNT_OBJ | DCNT_OBJ_1D;

    // BG0: charblock 0, screenblock 30, 4bpp, size 64x32 (size=1)
    REG_BG0CNT = BG_CBB(0) | BG_SBB(30) | BG_4BPP | BG_REG_64x32;

    // Palettes
    memcpy16(pal_bg_mem,  bg_pal,  16);
    memcpy16(pal_obj_mem, obj_pal, 16);

    // BG tiles into charblock 0
    memcpy32(&tile_mem[0][0], bg_tiles_4bpp, sizeof(bg_tiles_4bpp)/4);

    // OBJ tiles
    // Player at tile index OBJ_TILE_PLAYER
    memcpy32(&tile_mem_obj[OBJ_TILE_PLAYER], spr_player_4bpp, sizeof(spr_player_4bpp)/4);
    // Bullet at OBJ_TILE_BULLET
    memcpy32(&tile_mem_obj[OBJ_TILE_BULLET], spr_bullet_4bpp, sizeof(spr_bullet_4bpp)/4);
    // Enemy at OBJ_TILE_ENEMY
    memcpy32(&tile_mem_obj[OBJ_TILE_ENEMY],  spr_enemy_4bpp,  sizeof(spr_enemy_4bpp)/4);

    // OAM init
    oam_init(obj_buffer, 128);
}

#if USE_MAXMOD
static void init_sound(void)
{
    irq_init(NULL);
    irq_add(II_VBLANK, vblank_isr);

    // If you pasted a valid mmutil soundbank, this will work.
    // Otherwise, it may crash: that’s why the paste section matters.
    mmInitDefault((mm_addr)soundbank_bin, 8);

    // Start music (loop)
    mmStart(MOD_MUSIC, MM_PLAY_LOOP);

    // Reasonable volume (0..255)
    mmSetModuleVolume(192);
}
#endif

int main(void)
{
    init_gfx();

    build_room(g_room, g_map);
    load_room_to_vram();
    reset_entities_for_room(g_room);

#if USE_MAXMOD
    init_sound();
#else
    irq_init(NULL);
    irq_add(II_VBLANK, NULL);
#endif

    while(1)
    {
        VBlankIntrWait();

#if USE_MAXMOD
        // Maxmod expects mmFrame to be called once per frame in your main loop. [2]
        mmFrame();
#endif

        update_player();
        update_bullets();
        update_enemies();
        update_camera();
        render();

        // Copy OAM during VBlank
        oam_copy(oam_mem, obj_buffer, 128);

        // If player "dies", quick reset.
        if(g_pl.hp <= 0)
        {
            g_room = 0;
            build_room(g_room, g_map);
            load_room_to_vram();
            reset_entities_for_room(g_room);
        }
    }
}
