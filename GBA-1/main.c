// =================================================================================
// GBA METROID-LIKE PROTOTYPE (Single File)
// Uses: libtonc (Graphics/Input), maxmod (Sound)
// =================================================================================

#include <tonc.h>
#include <maxmod.h>
#include <stdlib.h>

// =================================================================================
// ASSETS (Embedded Data)
// =================================================================================

// 1. PALETTE (16 colors)
// Index 1: Samus Orange, Index 2: Ground Blue, Index 3: Bullet Yellow
const unsigned short main_pal[16] = {
    RGB15(0,0,0),    RGB15(31,15,0),  RGB15(0,10,25),  RGB15(31,31,0),
    RGB15(31,0,0),   RGB15(0,31,0),   RGB15(0,0,31),   RGB15(20,20,20),
    0,0,0,0,0,0,0,0
};

// 2. TILES (4bpp, 8x8 pixels)
// Tile 0: Empty
// Tile 1: Solid Block (Ground)
// Tile 2: Player (Simple Box)
// Tile 3: Bullet (Small dot)
const unsigned int tile_data[32] = {
    // Tile 0: Empty
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    // Tile 1: Ground Block (Color Index 2)
    0x22222222, 0x22222222, 0x22000022, 0x22000022,
    0x22000022, 0x22000022, 0x22222222, 0x22222222,
    // Tile 2: Player (Color Index 1)
    0x00111100, 0x01111110, 0x11111111, 0x11111111,
    0x11111111, 0x11111111, 0x01111110, 0x00111100,
    // Tile 3: Bullet (Color Index 3)
    0x00000000, 0x00000000, 0x00033000, 0x00333300,
    0x00333300, 0x00033000, 0x00000000, 0x00000000,
};

// 3. MAP DATA (30x20 tiles)
// A simple room with a floor and some platforms
#define MAP_W 30
#define MAP_H 20
u16 map_layout[MAP_W * MAP_H]; // Populated in init_map()

// 4. DUMMY SOUNDBANK
// In a real project, this is generated by 'mmutil'.
// We declare it here so the code structure is valid.
const u8 soundbank_bin[] = { 0,0,0,0,0,0,0,0 }; 

// Sound IDs (Placeholder)
#define SFX_JUMP  0
#define SFX_SHOOT 1

// =================================================================================
// GAME CONSTANTS & STRUCTS
// =================================================================================

#define GRAVITY     0x40  // Fixed point .8
#define JUMP_FORCE  0x550
#define MOVE_SPEED  0x200
#define BULLET_SPD  0x500

typedef struct {
    int x, y;       // Position (Fixed point 24.8)
    int dx, dy;     // Velocity
    int width, height;
    int facing;     // 1 = Right, -1 = Left
    bool grounded;
} Entity;

typedef struct {
    int x, y;
    int dx;
    bool active;
    int life;
} Bullet;

#define MAX_BULLETS 5
Entity player;
Bullet bullets[MAX_BULLETS];
OBJ_ATTR obj_buffer[128];

// =================================================================================
// FUNCTIONS
// =================================================================================

// Initialize the Map Layout
void init_map() {
    int x, y;
    for(y=0; y<MAP_H; y++) {
        for(x=0; x<MAP_W; x++) {
            // Create borders and floor
            if(y == MAP_H-1 || x == 0 || x == MAP_W-1 || y == 0) 
                map_layout[y*MAP_W + x] = 1;
            // Create some platforms
            else if(y == 14 && x > 5 && x < 10) map_layout[y*MAP_W + x] = 1;
            else if(y == 11 && x > 12 && x < 18) map_layout[y*MAP_W + x] = 1;
            else if(y == 8 && x > 20 && x < 25) map_layout[y*MAP_W + x] = 1;
            else map_layout[y*MAP_W + x] = 0;
        }
    }
}

// Simple AABB vs Tile collision
// Returns true if the entity overlaps a solid tile
bool check_map_collision(int x, int y, int w, int h) {
    // Convert px to tiles
    int t_left = x >> 3;
    int t_right = (x + w - 1) >> 3;
    int t_top = y >> 3;
    int t_bottom = (y + h - 1) >> 3;

    // Boundary checks
    if(t_left < 0 || t_right >= MAP_W || t_top < 0 || t_bottom >= MAP_H) return true;

    // Check corners
    if(map_layout[t_top * MAP_W + t_left] == 1) return true;
    if(map_layout[t_top * MAP_W + t_right] == 1) return true;
    if(map_layout[t_bottom * MAP_W + t_left] == 1) return true;
    if(map_layout[t_bottom * MAP_W + t_right] == 1) return true;

    return false;
}

void init_game() {
    // 1. Graphics Init
    REG_DISPCNT = DCNT_MODE0 | DCNT_BG0 | DCNT_OBJ | DCNT_OBJ_1D;
    
    // Copy Palette
    dma3_cpy(pal_bg_mem, main_pal, sizeof(main_pal));
    dma3_cpy(pal_obj_mem, main_pal, sizeof(main_pal));
    
    // Copy Tiles
    dma3_cpy(&tile_mem[0][0], tile_data, sizeof(tile_data));      // BG Tiles
    dma3_cpy(&tile_mem[4][0], tile_data, sizeof(tile_data));      // OBJ Tiles

    // Setup BG0
    init_map();
    REG_BG0CNT = BG_CBB(0) | BG_SBB(30) | BG_4BPP | BG_REG_32x32;
    // Copy map to Screen Block 30
    dma3_cpy(se_mem[30], map_layout, sizeof(map_layout));

    // 2. Sound Init (Maxmod)
    irq_init(NULL);
    irq_add(II_VBLANK, mmVBlank);
    
    // In a real app, soundbank_bin would be valid data
    // mmInitDefault((mm_addr)soundbank_bin, 8); 

    // 3. Player Init
    player.x = 40 << 8; // Pixel 40
    player.y = 100 << 8;
    player.width = 8;
    player.height = 8;
    player.facing = 1;
    player.dx = 0;
    player.dy = 0;

    // 4. OAM Init
    oam_init(obj_buffer, 128);
}

void update_player() {
    // Horizontal Movement
    player.dx = 0;
    if(key_held(KEY_LEFT)) {
        player.dx = -MOVE_SPEED;
        player.facing = -1;
    }
    if(key_held(KEY_RIGHT)) {
        player.dx = MOVE_SPEED;
        player.facing = 1;
    }

    // Apply X Velocity
    int new_x = player.x + player.dx;
    if(!check_map_collision(new_x >> 8, player.y >> 8, player.width, player.height)) {
        player.x = new_x;
    }

    // Jump
    if(key_hit(KEY_A) && player.grounded) {
        player.dy = -JUMP_FORCE;
        player.grounded = false;
        // mmEffect(SFX_JUMP); // Play sound
    }

    // Gravity
    player.dy += GRAVITY;

    // Apply Y Velocity
    int new_y = player.y + player.dy;
    if(check_map_collision(player.x >> 8, new_y >> 8, player.width, player.height)) {
        if(player.dy > 0) player.grounded = true; // Landed
        player.dy = 0;
    } else {
        player.y = new_y;
        player.grounded = false;
    }
}

void fire_bullet() {
    for(int i=0; i<MAX_BULLETS; i++) {
        if(!bullets[i].active) {
            bullets[i].active = true;
            bullets[i].x = player.x;
            bullets[i].y = player.y;
            bullets[i].dx = (player.facing == 1) ? BULLET_SPD : -BULLET_SPD;
            bullets[i].life = 30;
            // mmEffect(SFX_SHOOT); // Play sound
            break;
        }
    }
}

void update_bullets() {
    if(key_hit(KEY_B)) fire_bullet();

    for(int i=0; i<MAX_BULLETS; i++) {
        if(bullets[i].active) {
            bullets[i].x += bullets[i].dx;
            bullets[i].life--;
            
            int px = bullets[i].x >> 8;
            int py = bullets[i].y >> 8;

            // Check collision or lifetime
            if(bullets[i].life <= 0 || check_map_collision(px, py, 4, 4)) {
                bullets[i].active = false;
            }
        }
    }
}

void draw_game() {
    // 1. Draw Player (OAM index 0)
    obj_set_attr(&obj_buffer[0], 
        ATTR0_SQUARE | ATTR0_Y(player.y >> 8),
        ATTR1_SIZE_8 | ATTR1_X(player.x >> 8) | (player.facing == -1 ? ATTR1_HFLIP : 0),
        ATTR2_PALBANK(0) | 2); // Tile index 2

    // 2. Draw Bullets (OAM indices 1-5)
    for(int i=0; i<MAX_BULLETS; i++) {
        if(bullets[i].active) {
            obj_set_attr(&obj_buffer[i+1],
                ATTR0_SQUARE | ATTR0_Y(bullets[i].y >> 8),
                ATTR1_SIZE_8 | ATTR1_X(bullets[i].x >> 8),
                ATTR2_PALBANK(0) | 3); // Tile index 3
        } else {
            obj_set_attr(&obj_buffer[i+1], ATTR0_HIDE, 0, 0);
        }
    }

    // Update OAM to hardware
    oam_copy(oam_mem, obj_buffer, 6);
}

int main() {
    init_game();

    while(1) {
        // Poll buttons
        key_poll();

        update_player();
        update_bullets();

        // Wait for VBlank (good for power saving and timing)
        VBlankIntrWait();

        // Maxmod Frame Update (keep audio buffer full)
        mmFrame();
        
        draw_game();
    }

    return 0;
}
